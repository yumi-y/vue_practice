## 认识组件化

### 组件化

我们将页面拆分成一个个小的功能块，每个功能块完成属于自己的独立的功能，方便后期整个页面的管理和维护

### 注册组件的基本步骤

- 创建组件构造器

```js
//使用Vue.extend创建一个组件构造器
//传入template代表我们自定义组件的模版，该模版就是使用到组件的地方要显示的html代码
const cpnC = Vue.extend({
  //template设置一个模版
  template: ` 
  <div>
    <h2>标题</h2> 
    <p>内容</p> 
  </div>
  `,
});
```

- 注册组件

```js
//使用Vue.component()将刚才的组件构造器注册为一个组件自定义一个组件的标签名称
//传递的两个参数为1、注册组件的标签名 2、组件构造器
Vue.component("my-cpn", cpnC);
```

- 使用组件

```js
//使用组件，必须挂载在某个vue的实例下
<div id="app">
   <my-cpn></my-cpn>
 </div>
```

### 全局组件和局部组件

- 全局组件：意味着组件可以在任意的Vue中使用
- 局部组件：是挂载在某个具体的Vue实例当中

```js
//在Vue实例中添加以下代码构建局部组件
components: {
  //cpn使用组件时的标签名
  cpn: cpnC,
},
```

### 父组件和子组件

- 父组件在根组件即Vue实例中进行注册，子组件在父组件当中进行注册
- 直接调用父组件可以返回父组件和子组件结合
- 在顶层组件vue实例中没注册子组件，不能直接调用，要在根组件中在注册一次子组件，才能单独调用子组件
- 共同调用时，父组件可返回，子组件不可返回
- 在vue实例中再注册一次子组件，即可正常返回子组件和父组件

### 注册组件语法糖

- 省去了调用Vue.extend()的步骤，直接使用一个对象来代替

```js
Vue.component("cpn1", {
  template: `
  <div>
    <h2>我是标题1</h2>
    <p>我是内容1</p>
  </div>`,
});
```

### 模版的分离写法

- 将模版写到单独的script标签中，注意类型要转换成text/x-template

```js
<script type="text/x-template" id="cpn">
  <div>
    <h2>标题1</h2>
    <p>内容1</p>
  </div>
</script>
```

- 直接使用template标签来写模版，也要写ID

```js
<template id="cpn">
  <div>
    <h2>标题1</h2>
    <p>内容1</p>
  </div>
</template>
```

### 组件数据存放

- 组件是一个单独功能模块的封装，也有属于自己的数据data属性，即Vue组件有自己保存数据的地方
- 组件对象里有一个data属性，但这个data属性必须是一个函数，这个函数返回一个对象，内部保存着数据
- data属性是一个函数的原因是：函数调用时会赋予一个新的对象，解决组件在复用产生相互影响等问题

### 父子组件的通信

- 父级向子级传递（使用props）
  - 字符串数组，数组中的字符串就是传递时的名称
  - 对象，对象可以设置传递时的类型，也可以设置默认值（当props进行类型验证时，就需要对象写法）
    - String
    - Number
    - Boolean
    - Array
    - Object
    - Date 
    - Function  
    - Symbol 
  - 需要用v-bind绑定组件，在创建的组件中用props传数据，对象写法在没传入数据时可以提供一些默认值
  - 类型是对象或数组时，默认值必须是一个函数
- 子级向父级传递（需自定义事件）
  - 在子组件中，通过$emit()来触发事件
  - 在父组件中注册该组件，并通过v-on来监听子组件事件

```js
methods: {
//由子组件向父组件传送数据,则发送一个事件，在父组件设置@(v-on)监听一个事件，再设置相关的一个父组件方法
  btnClick(item) {
    //发射事件，自定义时间
    this.$emit("item-click", item);
  },
},
```

